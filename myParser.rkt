#lang racket


(require parser-tools/lex
         (prefix-in : parser-tools/lex-sre)
         parser-tools/yacc)

(require "myLexer.rkt")
(require "datatypes.rkt")


(define my-simple-parser
           (parser
            (start Program)
            (end EOF)
            (error (lambda (a b c) (display a)))
            (tokens a b)
            (grammar
             (Program ((Statements) (a-program $1)))
             (Statements ((Statement semicolon) (list $1))
                         ((Statements Statement semicolon) (append $1 (list $2))))
             (Statement ((Compound-stmt) (compound-stmt $1))
                        ((Simple-stmt) (simple-stmt $1)))
             (Simple-stmt ((Assignment) $1)
                          ((Return-stmt) $1)
                          ((Global-stmt) $1)
                          ((pass) (pass-stmt))
                          ((break) (break-stmt))
                          ((continue) (continue-stmt))
                          ((Print) $1)
                          ((Evaluate) $1))
             (Compound-stmt ((Function-def) $1)
                            ((If-stmt) $1)
                            ((For-stmt) $1))
             (Assignment ((ID assignment Expression)
                          (assign-stmt (string->symbol $1) $3)))
             (Return-stmt ((return) (return-stmt '()))
                          ((return Expression) (return-stmt $2)))
             (Global-stmt ((global ID) (global-stmt (string->symbol $2))))
             (Function-def ((def ID openParenthesis Params closeParenthesis colon Statements)
                            (function-def (string->symbol $2) $4 $7))
                           ((def ID openParenthesis closeParenthesis colon Statements)
                            (function-def (string->symbol $2) (list) $6)))
             (Params ((Param-with-default) (list $1))
                     ((Params comma Param-with-default) (append $1 (list $3))))
             (Param-with-default ((ID assignment Expression)
                                  (param-with-default (string->symbol $1) $3)))
             (If-stmt ((if Expression colon Statements Else-block)
                       (if-stmt $2 $4 $5)))
             (Else-block ((else colon Statements) $3))
             (For-stmt ((for ID in Expression colon Statements)
                        (for-stmt (string->symbol $2) $4 $6)))
             (Expression ((Disjunction) (disjunc $1)))
             (Disjunction ((Conjunction) (simple-disjunct $1))
                          ((Disjunction or Conjunction) (compound-disjunct $1 $3)))
             (Conjunction ((Inversion) (simple-conjunct $1))
                          ((Conjunction and Inversion) (compound-conjunct $1 $3)))
             (Inversion ((not Inversion) (not-inv $2))
                        ((Comparison) (comp-inv $1)))
             (Comparison ((Sum equals Sum) (eq-sum $1 $3))
                         ((Sum lessThan Sum) (lt-sum $1 $3))
                         ((Sum greaterThan Sum) (gt-sum $1 $3))
                         ((Sum) (simple-comp $1)))
             (Sum ((Sum plus Term) (addition-sum $1 $3))
                  ((Sum minus Term) (subtraction-sum $1 $3))
                  ((Term) (simple-sum $1)))
             (Term ((Term mul Factor) (mult-factor $1 $3))
                   ((Term div Factor) (div-factor $1 $3))
                   ((Factor) (simple-term $1)))
             (Factor ((plus Factor) (plus-factor $2))
                     ((minus Factor) (minus-factor $2))
                     ((Power) (simple-factor $1)))
             (Power ((Atom pow Factor) (to-power $1 $3))
                    ((Primary) (simple-power $1)))
             (Primary ((Atom) (primary-simple $1))
                      ((Primary openBracket Expression closeBracket)
                       (primary-indexed $1 $3))
                      ((Primary openParenthesis closeParenthesis)
                       (primary-called $1 '()))
                      ((Primary openParenthesis Arguments closeParenthesis)
                       (primary-called $1 $3)))
             (Arguments ((Expression) (list $1))
                        ((Arguments comma Expression) (append $1 (list $3))))
             (Atom ((ID) (atom-var (string->symbol $1)))
                   ((true) (atom-bool 'True))
                   ((false) (atom-bool 'False))
                   ((none) (atom-none))
                   ((NUM) (atom-number $1))
                   ((List) (atom-list $1)))
             (Atom-list ((Atom) (list $1))
                        ((Atom-list comma Atom) (append $1 (list $3))))
             (List ((openBracket Expressions closeBracket) $2)
                   ((openBracket closeBracket) (list)))
             (Expressions ((Expressions comma Expression) (append $1 (list $3)))
                          ((Expression) (list $1)))
             (Print ((print openParenthesis Expressions closeParenthesis)
                          (print-stmt $3)))
             (Evaluate ((evaluate openParenthesis PATH closeParenthesis)
                        (evaluate-stmt (substring $3 1 (- (string-length $3) 1))))))))

;test
(define lex-this (lambda (lexer input) (lambda () (lexer input))))
(define (my-lexer file-path) (lex-this my-simple-lexer (open-input-file file-path)))
;(let ((parser-res (my-simple-parser my-lexer))) parser-res)

(define parse
  (lambda (file-path)
    (my-simple-parser (my-lexer file-path))))

(provide parse)
